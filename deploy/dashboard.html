<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dashboard - Test de Orientación Vocacional</title>
    <link rel="icon" type="image/png" href="jovenes-conectados-favicon.png">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script type="module">
import { fetchAllSessions } from './assets/js/db_sessions.js';

/**
 * Fetch test results from both SQLite (sessions API) and legacy API, merge and deduplicate.
 */
async function fetchCombinedTestResults() {
    let dbSessions = [];
    let legacyResults = [];
    try {
        dbSessions = await fetchAllSessions();
    } catch (e) {
        console.warn('Could not fetch DB sessions:', e);
    }
    try {
        // Legacy API fetch (as in original fetchTestResults)
        const response = await fetch('http://localhost:8000/api/get_results.php', {
            headers: {
                'Accept': 'application/json',
                'Content-Type': 'application/json'
            },
            mode: 'cors'
        });
        if (response.ok) {
            const responseData = await response.json();
            legacyResults = Array.isArray(responseData.data) ? responseData.data : [];
        }
    } catch (e) {
        console.warn('Could not fetch legacy results:', e);
    }
    // Normalize DB sessions to legacy format if needed
    const normalizedDb = dbSessions.map(s => ({
        id: s.id,
        result: s.state ? (JSON.parse(s.state).result || '') : '',
        answers: s.state ? (JSON.parse(s.state).answerPattern || []) : [],
        date: s.created_at,
        ...s
    }));
    // Deduplicate by session_id or result/date
    const all = [...legacyResults, ...normalizedDb];
    const seen = new Set();
    const deduped = all.filter(item => {
        const key = item.session_id || (item.result + '_' + item.date);
        if (seen.has(key)) return false;
        seen.add(key);
        return true;
    });
    return deduped;
}
// Patch fetchTestResults to use combined source
window.fetchTestResults = fetchCombinedTestResults;
</script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
        }
        h1, h2, h3 {
            color: #2c3e50;
        }
        .header-container {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }
        .stat-card {
            background: white;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        .chart-container {
            margin: 30px 0 40px 0;
            position: relative;
            height: 300px;
            padding: 20px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        .dashboard-logo {
            width: 180px;
            height: auto;
        }
        .recent-tests {
            margin: 40px 0 20px 0;
            padding: 20px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 15px;
        }
        th, td {
            padding: 12px 15px;
            text-align: left;
            border-bottom: 1px solid #ddd;
        }
        th {
            background-color: #f8f9fa;
            font-weight: 600;
        }
        tr:hover {
            background-color: #f5f5f5;
        }
        .back-link {
            display: inline-block;
            margin-bottom: 20px;
            color: #001EB4;
            text-decoration: none;
            font-weight: 500;
        }
        .back-link:hover {
            text-decoration: underline;
        }
        .no-data {
            text-align: center;
            background-color: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            padding: 15px;
            color: #495057;
            font-size: 16px;
            font-style: normal;
            margin-top: 30px;
        }
        .answer-pattern {
            font-family: monospace;
            font-size: 14px;
            white-space: nowrap;
        }
        .answer {
            display: inline-block;
            width: 20px;
            text-align: center;
            margin: 0 2px;
            padding: 2px 0;
            background: #f0f0f0;
            border-radius: 3px;
        }
        .answer:hover {
            background: #e0e0e0;
            cursor: help;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header-container">
            <div>
                <a href="jc_test_vocacional.html" class="back-link">← Volver al test</a>
                <h1>Dashboard de Resultados</h1>
            </div>
            <img src="jovenes-conectados-logo.png" alt="Jóvenes Conectados" class="dashboard-logo">
        </div>
        
        <div class="stats-grid">
            <div class="stat-card">
                <h3>Total de Pruebas</h3>
                <p id="total-tests">0</p>
            </div>
            <div class="stat-card">
                <h3>Ruta Más Popular</h3>
                <p id="top-route">-</p>
            </div>
            <div class="stat-card">
                <h3>Prueba Más Reciente</h3>
                <p id="last-test">-</p>
            </div>
            <div class="stat-card">
                <h3>Hoy</h3>
                <p id="tests-today">0</p>
            </div>
            <div class="stat-card">
                <h3>Ayer</h3>
                <p id="tests-yesterday">0</p>
            </div>
            <div class="stat-card">
                <h3>Esta Semana</h3>
                <p id="tests-week">0</p>
            </div>
            <div class="stat-card">
                <h3>Este Mes</h3>
                <p id="tests-month">0</p>
            </div>
        </div>

        <div id="chart-container" class="chart-container">
            <h2>Distribución de Rutas</h2>
            <canvas id="routesChart"></canvas>
        </div>

        <div class="recent-tests">
            <h2>Pruebas Recientes</h2>
            <div id="recent-tests-container">
                <p class="no-data">No hay datos de pruebas disponibles.</p>
            </div>
        </div>
    </div>

    <script>
// Define questions array for route calculations
const questions = [
    {
        q: "1. ¿Qué actividad te resulta más atractiva?",
        options: [
            { text: "Crear contenido visual o escribir para redes", routes: ["Diseño de contenido", "Marketing en redes"] },
            { text: "Resolver problemas con lógica o códigos", routes: ["Programación", "Desarrollo de software"] },
            { text: "Pensar en nuevas ideas para negocios", routes: ["Emprendimiento", "Creatividad e innovación"] },
            { text: "Ayudar a los demás o resolver consultas", routes: ["Servicio al cliente", "Ventas"] }
        ]
    },
    {
        q: "2. ¿Qué preferís aprender?",
        options: [
            { text: "Herramientas como Excel, Word, PowerPoint", routes: ["Competencias digitales"] },
            { text: "Cómo gestionar recursos y tareas", routes: ["Manejo de proyectos"] },
            { text: "Cómo proteger la información en internet", routes: ["Ciberseguridad"] },
            { text: "Cómo tomar decisiones con números", routes: ["Contabilidad", "Análisis de datos"] }
        ]
    },
    {
        q: "3. ¿Te gustaría trabajar más con...?",
        options: [
            { text: "Gente, clientes o audiencias", routes: ["Servicio al cliente", "Marketing", "Ventas"] },
            { text: "Computadoras y tecnología", routes: ["IA", "Software", "Ciberseguridad"] },
            { text: "Ideas nuevas y creatividad", routes: ["Creatividad", "Diseño", "Emprendimiento"] },
            { text: "Organización y procesos", routes: ["Transformación digital", "Proyectos", "Contabilidad"] }
        ]
    },
    {
        q: "4. Si tenés que hacer un proyecto escolar, ¿qué rol preferís?",
        options: [
            { text: "Diseñar la presentación o editar el video", routes: ["Diseño de contenido"] },
            { text: "Coordinar al equipo y definir tareas", routes: ["Manejo de proyectos"] },
            { text: "Analizar datos o gráficos", routes: ["Análisis de datos", "Contabilidad"] },
            { text: "Investigar o buscar soluciones técnicas", routes: ["IA", "Software", "Ciberseguridad"] }
        ]
    },
    {
        q: "5. ¿Cuál de estas frases se parece más a vos?",
        options: [
            { text: "Tengo buena imaginación y muchas ideas", routes: ["Creatividad e innovación"] },
            { text: "Soy práctico y resuelvo problemas técnicos", routes: ["Programación", "Análisis de datos"] },
            { text: "Me gusta atender y entender a las personas", routes: ["Servicio al cliente", "Ventas"] },
            { text: "Soy ordenado/a y me fijo en los detalles", routes: ["Contabilidad", "Proyectos"] }
        ]
    },
    {
        q: "6. ¿Qué tipo de contenido te interesa ver o crear?",
        options: [
            { text: "Videos, memes, campañas", routes: ["Diseño de contenido", "Marketing"] },
            { text: "Juegos, apps, herramientas", routes: ["Desarrollo de software", "Videojuegos"] },
            { text: "Planes de negocios o estrategias", routes: ["Emprendimiento", "Transformación digital"] },
            { text: "Cursos, hojas de cálculo, documentos", routes: ["Competencias digitales", "Ofimática"] }
        ]
    },
    {
        q: "7. ¿Qué te gustaría saber hacer en un futuro cercano?",
        options: [
            { text: "Hacer crecer un emprendimiento", routes: ["Emprendimiento"] },
            { text: "Crear un videojuego o una app", routes: ["Videojuegos", "Software"] },
            { text: "Comunicar bien un producto o marca", routes: ["Marketing", "Ventas"] },
            { text: "Usar tecnología para resolver tareas", routes: ["Ofimática", "Transformación digital"] }
        ]
    },
    {
        q: "8. ¿Cuál de estas áreas te llama más la atención?",
        options: [
            { text: "Inteligencia Artificial o aprendizaje automático", routes: ["IA"] },
            { text: "Finanzas personales o registro de gastos", routes: ["Contabilidad"] },
            { text: "Herramientas para trabajar mejor en equipo", routes: ["Manejo de proyectos"] },
            { text: "Redes sociales y campañas digitales", routes: ["Marketing en redes"] }
        ]
    },
    {
        q: "9. ¿Qué elegís si tenés 2 horas libres para aprender algo nuevo?",
        options: [
            { text: "Tomar un curso creativo o de diseño", routes: ["Diseño de contenido"] },
            { text: "Investigar sobre cómo funciona un sistema", routes: ["Software", "IA"] },
            { text: "Aprender técnicas de ventas o atención al cliente", routes: ["Ventas", "Servicio al cliente"] },
            { text: "Organizar información o datos", routes: ["Análisis de datos", "Competencias digitales"] }
        ]
    },
    {
        q: "10. ¿Qué frase te representa mejor?",
        options: [
            { text: "Tengo buena imaginación y muchas ideas", routes: ["Creatividad", "IA"] },
            { text: "Soy práctico y resuelvo problemas técnicos", routes: ["Programación", "Análisis de datos"] },
            { text: "Me gusta atender y entender a las personas", routes: ["Servicio al cliente", "Ventas"] },
            { text: "Soy ordenado/a y me fijo en los detalles", routes: ["Contabilidad", "Proyectos"] }
        ]
    },
    {
        q: "11. ¿Cuál de estas actividades elegirías en una feria de profesiones?",
        options: [
            { text: "Hacer una app o juego", routes: ["Desarrollo de software", "Videojuegos"] },
            { text: "Vender un producto con una estrategia", routes: ["Ventas", "Marketing"] },
            { text: "Hacer una campaña visual", routes: ["Diseño de contenido"] },
            { text: "Armar un plan para un nuevo negocio", routes: ["Emprendimiento"] }
        ]
    },
    {
        q: "12. ¿Cuál sería tu 'súper poder' ideal?",
        options: [
            { text: "Entender el lenguaje de las máquinas", routes: ["Programación", "IA"] },
            { text: "Hacer que la gente diga 'wow' con una presentación", routes: ["Creatividad", "Diseño de contenido"] },
            { text: "Convencer a cualquiera de comprar algo", routes: ["Ventas", "Marketing"] },
            { text: "Organizarlo todo para que funcione perfecto", routes: ["Proyectos", "Contabilidad"] }
        ]
    }
];
        // Function to fetch test results
        async function fetchTestResults() {
            console.log('Fetching test results from API...');
            try {
                const response = await fetch('http://localhost:8000/api/get_results.php', {
                    headers: {
                        'Accept': 'application/json',
                        'Content-Type': 'application/json'
                    },
                    mode: 'cors'
                });
                
                console.log('Response status:', response.status);
                
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('Error response:', errorText);
                    throw new Error(`Error al cargar los resultados: ${response.status} ${response.statusText}`);
                }
                
                const responseData = await response.json();
                console.log('API Response:', responseData);
                
                if (!responseData || (Array.isArray(responseData) && responseData.length === 0)) {
                    console.warn('No test results found');
                    return [];
                }
                
                // Always use responseData.data if present (API returns {success:true, data:[...]})
                const results = Array.isArray(responseData.data) ? responseData.data : [];
                console.log('Raw API results:', results);
                // Process and normalize the test history data
                const normalized = results.map(test => {
                    try {
                        // Safely parse topRoutes
                        let topRoutes = [];
                        if (Array.isArray(test.topRoutes)) {
                            topRoutes = test.topRoutes;
                        } else if (typeof test.topRoutes === 'string') {
                            try {
                                topRoutes = JSON.parse(test.topRoutes);
                                if (!Array.isArray(topRoutes)) topRoutes = [];
                            } catch (e) {
                                console.warn('Error parsing topRoutes:', e);
                                topRoutes = [];
                            }
                        }

                        // Safely parse fullAnswers
                        let fullAnswers = [];
                        if (Array.isArray(test.fullAnswers)) {
                            fullAnswers = test.fullAnswers;
                        } else if (typeof test.fullAnswers === 'string') {
                            try {
                                fullAnswers = JSON.parse(test.fullAnswers);
                                if (!Array.isArray(fullAnswers)) fullAnswers = [];
                            } catch (e) {
                                console.warn('Error parsing fullAnswers:', e);
                                fullAnswers = [];
                            }
                        }

                        // Defensive: fill missing fields
                        return {
                            id: test.id || null,
                            result: test.result || '',
                            answers: test.answers || [],
                            date: test.date || test.created_at || new Date().toISOString(),
                            topRoutes,
                            fullAnswers,
                            ...test
                        };
                    } catch (e) {
                        console.warn('Error normalizing test result:', e, test);
                        return test;
                    }
                });
                console.log('Normalized results:', normalized);
                return normalized.filter(Boolean); // Remove any null entries from failed processing
                
            } catch (error) {
                console.error('Error in fetchTestResults:', error);
                throw error;
            }
        }
        
        // Function to calculate metrics from test results
        function calculateMetrics(testHistory = [], today, yesterdayStr) {
            // Ensure testHistory is an array
            const history = Array.isArray(testHistory) ? testHistory : [];
            
            if (history.length === 0) {
                return {
                    testsToday: 0,
                    testsYesterday: 0,
                    testsThisWeek: 0,
                    testsThisMonth: 0
                };
            }
            
            const testsToday = history.filter(test => {
                try {
                    const testDate = new Date(test.date || test.test_date || test.created_at || Date.now()).toISOString().split('T')[0];
                    return testDate === today;
                } catch (e) {
                    console.error('Error processing test date:', e);
                    return false;
                }
            }).length;
            
            const testsYesterday = history.filter(test => {
                try {
                    const testDate = new Date(test.date || test.test_date || test.created_at || Date.now()).toISOString().split('T')[0];
                    return testDate === yesterdayStr;
                } catch (e) {
                    console.error('Error processing test date:', e);
                    return false;
                }
            }).length;
            
            return {
                testsToday,
                testsYesterday,
                testsThisWeek: history.length, // Simplified for now
                testsThisMonth: history.length  // Simplified for now
            };
        }
        
        // Function to update the UI with test history
        function updateTestHistoryUI(history, recentTestsContainer) {
            if (!recentTestsContainer) return;
            
            if (!history || !Array.isArray(history)) {
                if (recentTestsContainer) {
    recentTestsContainer.innerHTML = `
        <div class="alert alert-info">
            No se encontraron resultados de pruebas. Realiza algunas pruebas para ver los datos aquí.
        </div>
    `;
}
                return;
            }
                
                if (history.length > 0) {
                    if (recentTestsContainer) {
    recentTestsContainer.innerHTML = `
        <h3>Detalles del último test</h3>
        ${history[0].answer_breakdown ? history[0].answer_breakdown : ''}
        ${history[0].formula_details ? history[0].formula_details : ''}
        <table>
            <thead>
                <tr>
                    <th>Fecha</th>
                    <th>Ruta</th>
                    <th>Respuestas</th>
                </tr>
            </thead>
            <tbody>
                ${history.slice(0, 10).map(test => `
                    <tr>
                        <td>${new Date(test.created_at).toLocaleString('es-ES')}</td>
                        <td>${(() => {
                            try {
                                const routes = test.topRoutes || [];
                                return routes.map(r => r.route).join(', ') || 'N/A';
                            } catch (e) {
                                console.error('Error parsing routes:', e);
                                return 'N/A';
                            }
                        })()}</td>
                        <td>
                            <div style="padding: 10px; background-color: #f8f9fa; border-radius: 8px; border: 1px solid #dee2e6;">
                                <div style="font-family: monospace; font-size: 14px;">
                                    ${(() => {
                                        try {
                                            return test.answers || test.answers === '' ? test.answers : 'N/A';
                                        } catch (e) {
                                            console.error('Error parsing answers:', e);
                                            return 'Error al cargar las respuestas';
                                        }
                                    })()}
                                </div>
                            </div>
                        </td>
                    </tr>
                `).join('')}
            </tbody>
        </table>
    `;
}
                } else {
                    if (recentTestsContainer) {
    recentTestsContainer.innerHTML = `
        <table>
            <thead>
                <tr>
                    <th>Fecha</th>
                    <th>Ruta</th>
                    <th>Respuestas</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td colspan="3">No se han encontrado pruebas recientes.</td>
                </tr>
            </tbody>
        </table>
    `;
}
                }
            }
            
            (async () => {
                try {
                    // Fetch test results
                    testHistory = await fetchTestResults();
                    console.log('Test history loaded:', testHistory);
                    
                    if (!testHistory || !Array.isArray(testHistory)) {
                        throw new Error('No se pudieron cargar los resultados del test');
                    }
                    
                    // Update the UI with the test history
                    updateTestHistoryUI(testHistory);
                    
                    // Get current date for metrics
                    const today = new Date().toISOString().split('T')[0];
                    const yesterday = new Date();
                    yesterday.setDate(yesterday.getDate() - 1);
                    const yesterdayStr = yesterday.toISOString().split('T')[0];
                    
                    // Calculate metrics
                    const metrics = calculateMetrics(testHistory, today, yesterdayStr);
                    
                    // Update metrics display with calculated values
                    document.getElementById('tests-today').textContent = metrics.testsToday;
                document.getElementById('tests-yesterday').textContent = metrics.testsYesterday;
                document.getElementById('tests-week').textContent = metrics.testsThisWeek;
                document.getElementById('tests-month').textContent = metrics.testsThisMonth;

                // Update basic stats
                document.getElementById('total-tests').textContent = testHistory.length;
                
                // Find most common route for display
                if (testHistory.length > 0) {
                    const routeCounts = testHistory.reduce((acc, test) => {
                        const routes = Array.isArray(test.topRoutes) ? test.topRoutes : [];
                        routes.forEach(route => {
                            if (route) acc[route] = (acc[route] || 0) + 1;
                        });
                        return acc;
                    }, {});
                    
                    const mostCommonRoute = Object.entries(routeCounts)
                        .sort((a, b) => b[1] - a[1])[0];
                        
                    if (mostCommonRoute) {
                        document.getElementById('top-route').textContent = 
                            `${mostCommonRoute[0]} (${mostCommonRoute[1]} pruebas)`;
                    }
                    
                    // Set last test date
                    const lastTest = testHistory[0];
                    try {
                        const date = new Date(lastTest.date || lastTest.created_at);
                        if (!isNaN(date.getTime())) {
                            document.getElementById('last-test').textContent = 
                                date.toLocaleDateString('es-ES', {
                                    year: 'numeric',
                                    month: 'long',
                                    day: 'numeric',
                                    hour: '2-digit',
                                    minute: '2-digit'
                                });
                        } else {
                            document.getElementById('last-test').textContent = 'Fecha no disponible';
                        }
                    } catch (e) {
                        console.error('Error formatting date:', e);
                        document.getElementById('last-test').textContent = 'Error en fecha';
                    }
                }
                
                // Prepare data for the chart
                const routeCounts = {};
                testHistory.forEach(test => {
                    const routes = Array.isArray(test.topRoutes) ? test.topRoutes : [];
                    routes.forEach(route => {
                        if (route) {  // Only count non-null/undefined routes
                            routeCounts[route] = (routeCounts[route] || 0) + 1;
                        }
                    });
                    
                    // Also check the result field for routes if topRoutes is empty
                    if (routes.length === 0 && test.result) {
                        const match = test.result.match(/Las rutas que más se ajustan a tu perfil son: ([^<]+)/);
                        if (match && match[1]) {
                            const routeNames = match[1].split(',').map(r => r.trim()).filter(Boolean);
                            routeNames.forEach(route => {
                                if (route) {
                                    routeCounts[route] = (routeCounts[route] || 0) + 1;
                                }
                            });
                        }
                    }
                });
                
                // Sort routes by count (descending) and get top 10
                const sortedRoutes = Object.entries(routeCounts)
                    .filter(([route]) => route && route.trim() !== '')
                    .sort((a, b) => b[1] - a[1])
                    .slice(0, 10); // Limit to top 10 routes
                
                const labels = sortedRoutes.map(([route]) => route || 'Sin ruta');
                const data = sortedRoutes.map(([_, count]) => count);
                
                // If no routes found, show a message
                if (labels.length === 0) {
                    const chartContainer = document.getElementById('chart-container');
                    if (chartContainer) {
                        chartContainer.innerHTML = '<p class="no-data">No hay suficientes datos para mostrar el gráfico de rutas.</p>';
                    } else {
                        console.error('Elemento chart-container no encontrado.');
                    }
                    return;
                }
                
                // Create chart
                const ctx = document.getElementById('routesChart').getContext('2d');
                // Jóvenes Conectados brand colors from logo
                const brandColors = [
                    '#2C3E50',  // Dark blue (main brand color)
                    '#3498DB',  // Bright blue (accent color)
                    '#E74C3C',  // Red (from logo elements)
                    '#2ECC71',  // Green (from logo elements)
                    '#F1C40F',  // Yellow (from logo elements)
                    '#9B59B6',  // Purple (from logo elements)
                    '#1ABC9C',  // Turquoise (from logo elements)
                    '#E67E22',  // Orange (from logo elements)
                    '#E74C3C',  // Red (from logo elements)
                    '#2C3E50'   // Dark blue (main brand color)
                ];


                new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: labels,
                        datasets: [{
                            label: 'Número de pruebas',
                            data: data,
                            backgroundColor: labels.map((_, i) => {
                                const color = brandColors[i % brandColors.length];
                                return color + 'CC'; // Add 80% opacity
                            }),
                            borderColor: labels.map((_, i) => brandColors[i % brandColors.length]),
                            borderWidth: 1,
                            borderRadius: 4,
                            borderSkipped: false
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            y: {
                                beginAtZero: true,
                                title: {
                                    display: true,
                                    text: 'Número de pruebas'
                                }
                            },
                            x: {
                                title: {
                                    display: true,
                                    text: 'Rutas'
                                }
                            }
                        },
                        plugins: {
                            legend: {
                                display: false
                            },
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        return `Pruebas: ${context.raw}`;
                                    }
                                }
                            }
                        }
                    }
                });
                
                // Show recent tests
                if (testHistory.length > 0) {
                    recentTestsContainer.innerHTML = `
                        <h3>Detalles del último test</h3>
                        
                        <!-- Add the formula details and answer breakdown from the most recent test -->
                        ${testHistory[0].answer_breakdown ? testHistory[0].answer_breakdown : ''}
                        ${testHistory[0].formula_details ? testHistory[0].formula_details : ''}
                        
                        <h3>Historial de pruebas</h3>
                        <table>
                            <thead>
                                <tr>
                                    <th>Fecha</th>
                                    <th>Ruta</th>
                                    <th>Patrón de respuestas</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${testHistory.slice(0, 10).map(test => `
                                    <tr>
                                        <td>${new Date(test.created_at).toLocaleString('es-ES')}</td>
                                        <td>${(() => {
                                            try {
                                                // Try to parse as JSON array first
                                                const answersArray = Array.isArray(test.answers) ? test.answers : 
                                                    (test.answers.startsWith('[') ? JSON.parse(test.answers) : 
                                                    Array.from(test.answers).map(letter => {
                                                        // Convert letter (A, B, C, D) to index (0, 1, 2, 3)
                                                        return letter.charCodeAt(0) - 65;
                                                    }));
                                                
                                                const routeCounts = answersArray.reduce((acc, val, idx) => {
                                                    const question = questions.find(q => q.options && q.options[val]?.routes);
                                                    if (question) {
                                                        const route = question.options[val].routes[0];
                                                        acc[route] = (acc[route] || 0) + 1;
                                                    }
                                                    return acc;
                                                }, {});
                                                
                                                const topRoute = Object.entries(routeCounts).sort((a, b) => b[1] - a[1])[0];
                                                return topRoute ? topRoute[0] : 'N/A';
                                            } catch (e) {
                                                console.log('Error parsing answers:', e);
                                                return 'Error';
                                            }
                                        })()}</td>
                                        <td class="answer-pattern">
                                            ${(() => {
                                                try {
                                                    // Handle both JSON array and string formats
                                                    const answersArray = Array.isArray(test.answers) ? test.answers : 
                                                        (test.answers.startsWith('[') ? JSON.parse(test.answers) : 
                                                        Array.from(test.answers));
                                                    
                                                    return answersArray.map((a, i) => {
                                                        // If a is already a letter (A, B, C, D), use it directly
                                                        // Otherwise, convert index to letter
                                                        const letter = isNaN(a) ? a : String.fromCharCode(65 + parseInt(a));
                                                        return `<span class="answer" title="Pregunta ${i + 1}">${letter}</span>`;
                                                    }).join('');
                                                } catch (e) {
                                                    console.log('Error parsing answers for pattern:', e);
                                                    return 'Error parsing answers';
                                                }
                                            })()}
                                        </td>
                                        <td>
                                            <div style="padding: 10px; background-color: #f8f9fa; border-radius: 8px; border: 1px solid #dee2e6;">
                                                <div style="font-family: monospace; font-size: 14px;">
                                                    ${(() => {
                                                        try {
                                                            // Handle both JSON array and string formats
                                                            const answersArray = Array.isArray(test.answers) ? test.answers : 
                                                                (test.answers.startsWith('[') ? JSON.parse(test.answers) : 
                                                                Array.from(test.answers));
                                                            
                                                            // Count letter frequencies
                                                            const letterCounts = answersArray.reduce((acc, val) => {
                                                                // If val is already a letter (A, B, C, D), use it directly
                                                                // Otherwise, convert index to letter
                                                                const letter = isNaN(val) ? val : String.fromCharCode(65 + parseInt(val));
                                                                acc[letter] = (acc[letter] || 0) + 1;
                                                                return acc;
                                                            }, {});
                                                            
                                                            // Format as A3, B6, C2, D1
                                                            return Object.entries(letterCounts)
                                                                .map(([letter, count]) => `${letter}${count}`)
                                                                .join(', ');
                                                        } catch (e) {
                                                            console.log('Error parsing answers for letter counts:', e);
                                                            return 'Error parsing answers';
                                                        }
                                                    })()}
                                                </div>
                                                <div style="margin-top: 8px; font-family: monospace; font-size: 12px;">
                                                    ${(() => {
                                                        const answers = JSON.parse(test.answers);
                                                        const routeScores = answers.reduce((acc, val, idx) => {
                                                            const question = questions.find(q => q.options && q.options[val]?.routes);
                                                            if (question && question.options[val]?.routes) {
                                                                question.options[val].routes.forEach(route => {
                                                                    acc[route] = (acc[route] || 0) + 1;
                                                                });
                                                            }
                                                            return acc;
                                                        }, {});
                                                        
                                                        // Format as "Route: score | Route: score"
                                                        return Object.entries(routeScores)
                                                            .map(([route, score]) => `${route}: ${score}`)
                                                            .join(' | ');
                                                    })()}
                                                </div>
                                            </div>
                                        </td>
                                    </tr>
                                `).join('')}
                            </tbody>
                        </table>
                    `;
                }
            } catch (error) {
                console.error('Error loading dashboard data:', error);
                // Show error message to user
                const errorContainer = document.querySelector('.no-data');
                if (errorContainer) {
                    errorContainer.innerHTML = `
                        <div class="error-message">
                            <h3>Error al cargar los datos</h3>
                            <p>${error.message || 'Ha ocurrido un error inesperado'}</p>
                            <p>Por favor, intenta recargar la página o contacta al soporte técnico.</p>
                        </div>
                        <div style="margin-top: 30px; padding: 15px; background-color: rgb(248, 249, 250); border-radius: 8px; border: 1px solid rgb(222, 226, 230); text-align: left;">
                            <h4 style="margin-bottom: 10px; color: rgb(73, 80, 87); text-align: left;">Desglose de respuestas:</h4>
                            <div style="font-family: monospace; font-size: 16px; text-align: left;">A3, B6, C2, D1</div>
                            <div style="margin-top: 10px; font-family: monospace; font-size: 14px; text-align: left;">Puntuaciones por ruta: Diseño de contenido: 3 | Marketing en redes: 1 | Manejo de proyectos: 2 | IA: 1 | Software: 1 | Ciberseguridad: 1 | Creatividad e innovación: 1 | Desarrollo de software: 1 | Videojuegos: 1 | Marketing: 1 | Ventas: 1 | Contabilidad: 2 | Programación: 1 | Análisis de datos: 1 | Proyectos: 1</div>
                    `;
                }
            }
            // Initialize routesData object
            const routesData = {};
            
            // Process routes data for the chart
            if (testHistory && Array.isArray(testHistory)) {
                testHistory.forEach(test => {
                    if (test && test.result) {
                        const mainPart = test.result.split(':')[1] || test.result; // Fallback to full result if no colon
                        const route = (mainPart.includes('.') ? mainPart.split('.')[0] : mainPart).trim();
                        if (route) { // Only process if we have a valid route
                            routesData[route] = (routesData[route] || 0) + 1;
                        }
                    }
                });
            }

            // Create chart with consistent brand colors
            const ctx = document.getElementById('routesChart').getContext('2d');
            const routeLabels = Object.keys(routesData);
            const routeData = Object.values(routesData);
            
            new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: routeLabels,
                    datasets: [{
                        label: 'Número de Pruebas',
                        data: routeData,
                        backgroundColor: routeLabels.map((_, i) => {
                            const color = brandColors[i % brandColors.length];
                            return color + 'CC'; // Add 80% opacity
                        }),
                        borderColor: routeLabels.map((_, i) => brandColors[i % brandColors.length]),
                        borderWidth: 1,
                        borderRadius: 4,
                        borderSkipped: false
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: true,
                            ticks: {
                                stepSize: 1,
                                font: {
                                    weight: 'bold'
                                }
                            },
                            grid: {
                                color: 'rgba(0, 0, 0, 0.05)'
                            }
                        },
                        x: {
                            ticks: {
                                font: {
                                    weight: 'bold'
                                }
                            },
                            grid: {
                                display: false
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            display: false
                        },
                        tooltip: {
                            backgroundColor: 'rgba(46, 134, 171, 0.9)',
                            titleFont: {
                                weight: 'bold',
                                size: 14
                            },
                            bodyFont: {
                                size: 13
                            },
                            padding: 12,
                            cornerRadius: 6,
                            displayColors: false
                        }
                    },
                    layout: {
                        padding: {
                            top: 10,
                            right: 15,
                            bottom: 10,
                            left: 15
                        }
                    },
                    animation: {
                        duration: 1000,
                        easing: 'easeOutQuart'
                    }
                }
            });

            // Initialize charts
            // initCharts(); // Removed: no such function, Chart.js handles charts directly
            
            try {
                // Get date strings for metrics
                const today = new Date();
                const todayStr = today.toISOString().split('T')[0];
                const yesterday = new Date();
                yesterday.setDate(yesterday.getDate() - 1);
                const yesterdayStr = yesterday.toISOString().split('T')[0];
                
                // Get DOM elements
                const recentTestsContainer = document.getElementById('recent-tests-container');
                
                // Fetch test results
                const testHistory = await fetchTestResults();
                console.log('Test history loaded:', testHistory);
                
                if (!testHistory || !Array.isArray(testHistory)) {
                    throw new Error('No se pudieron cargar los resultados del test');
                }
                
                // Update the UI with the test history
                updateTestHistoryUI(testHistory);
                
                // Calculate metrics
                const metrics = calculateMetrics(testHistory, today, yesterdayStr);
                
                // Update metrics display with calculated values
                document.getElementById('tests-today').textContent = metrics.testsToday;
                document.getElementById('tests-yesterday').textContent = metrics.testsYesterday;
                document.getElementById('tests-week').textContent = metrics.testsThisWeek;
                document.getElementById('tests-month').textContent = metrics.testsThisMonth;
        
                // Update basic stats
                document.getElementById('total-tests').textContent = testHistory.length;
                
                // Find most common route for display
                if (testHistory.length > 0) {
                    const routeCounts = testHistory.reduce((acc, test) => {
                        const routes = Array.isArray(test.topRoutes) ? test.topRoutes : [];
                        routes.forEach(route => {
                            if (route) acc[route] = (acc[route] || 0) + 1;
                        });
                        return acc;
                    }, {});
                    
                    const mostCommonRoute = Object.entries(routeCounts).sort((a, b) => b[1] - a[1])[0];
                    if (mostCommonRoute) {
                        document.getElementById('most-common-route').textContent = mostCommonRoute[0];
                    }
                }
                
                // Prepare data for charts
                const routeData = {};
                const dateData = {};
                // Reuse the existing 'today' variable from above
                const last7Days = Array.from({ length: 7 }, (_, i) => {
                    const d = new Date(today);
                    d.setDate(d.getDate() - i);
                    return d.toISOString().split('T')[0];
                }).reverse();
                
                testHistory.forEach(test => {
                    const testDate = new Date(test.date || test.created_at).toISOString().split('T')[0];
                    const routes = Array.isArray(test.topRoutes) ? test.topRoutes : [];
                    
                    // Count routes
                    routes.forEach(route => {
                        if (route) routeData[route] = (routeData[route] || 0) + 1;
                    });
                    
                    // Count tests by date
                    if (testDate) {
                        dateData[testDate] = (dateData[testDate] || 0) + 1;
                    }
                });
                
                // Sort routes by count
                const sortedRoutes = Object.entries(routeData)
                    .sort((a, b) => b[1] - a[1])
                    .slice(0, 5); // Top 5 routes
                
                // Prepare chart data
                const routeLabels = sortedRoutes.map(([route]) => route);
                const routeCounts = sortedRoutes.map(([_, count]) => count);
                
                const dateLabels = last7Days;
                const dateCounts = last7Days.map(date => dateData[date] || 0);
                
                // Create or update charts
                updateRouteChart(routeLabels, routeCounts);
                updateDateChart(dateLabels, dateCounts);
                
                // Update recent tests table
                updateRecentTestsTable(testHistory);
                
                // Update recent tests table
                const recentTestsHtml = testHistory.map(test => {
                    const date = new Date(test.date).toLocaleString('es-ES');
                    const mainRoute = test.result ? test.result.split(':')[0] : 'Desconocido';
                    const answers = test.answers || [];
                    const answersDisplay = Array.isArray(answers) 
                        ? answers.map(a => a.option || a).join(', ')
                        : JSON.stringify(answers);
                    
                    return `
                        <tr>
                            <td>${date}</td>
                            <td>${mainRoute}</td>
                            <td class="answer-pattern">${answersDisplay}</td>
                        </tr>
                    `;
                }).join('');
                
                if (recentTestsContainer) {
                    recentTestsContainer.innerHTML = `
                        <table>
                            <thead>
                                <tr>
                                    <th>Fecha</th>
                                    <th>Ruta principal</th>
                                    <th>Respuestas</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${recentTestsHtml || '<tr><td colspan="3">No hay pruebas recientes</td></tr>'}
                            </tbody>
                        </table>
                    `;
                }
            } catch (error) {
                console.error('Error loading dashboard data:', error);
                // Show error message to user
                const errorContainer = document.querySelector('.no-data');
                if (errorContainer) {
                    errorContainer.innerHTML = `
                        <div class="alert alert-danger">
                            <h3>Error al cargar los datos del tablero</h3>
                            <p>Error al cargar los datos del tablero: ${error.message}</p>
                        </div>
                    `;
                }
            }
        })();
        
        // Function to update the test history UI
        function updateTestHistoryUI(testHistory) {
            // TO DO: implement this function
        }
        
        // Function to calculate metrics
        function calculateMetrics(testHistory, today, yesterdayStr) {
            // TO DO: implement this function
            return {
                testsToday: 0,
                testsYesterday: 0,
                testsThisWeek: 0,
                testsThisMonth: 0
            };
        }
        
        // Function to update the route chart
        function updateRouteChart(routeLabels, routeCounts) {
            // TO DO: implement this function
        }
        
        // Function to update the date chart
        function updateDateChart(dateLabels, dateCounts) {
            // TO DO: implement this function
        }
        
        // Function to update the recent tests table
        function updateRecentTestsTable(testHistory) {
            // TO DO: implement this function
        }
        
        // Function to fetch test results
        async function fetchTestResults() {
            // TO DO: implement this function
            return [];
        }
    </script>
    <div style="display: none; margin-top: 30px; padding: 15px; background-color: #f8f9fa; border-radius: 8px; border: 1px solid #dee2e6;"><h4 style="margin-bottom: 10px; color: #495057;">Desglose de respuestas:</h4><div style="font-family: monospace; font-size: 16px;">B6, C3, A3</div><div style="margin-top: 10px; font-family: monospace; font-size: 14px;">Puntuaciones por ruta: Programación: 2 | Desarrollo de software: 3 | Ciberseguridad: 1 | Servicio al cliente: 3 | Marketing: 1 | Ventas: 3 | Manejo de proyectos: 1 | Videojuegos: 2 | Emprendimiento: 1 | Contabilidad: 1 | Análisis de datos: 1 | Creatividad: 1 | Diseño de contenido: 1</div></div>
</body>
</html>
